## CHAPTER 3. 람다 표현식
* 익명 클래스를 활용한 동작 파라미터화는 다양한 요구사항에 유연성있는 코드이지만, 아직 깔끔하지 못한 코드이다. 그래서 람다 표현식을 사용하여 더욱 깔끔한 코드를 구현할 수 있다.
* 람다 뿐만 아니라 자바 8에는 메소드 레퍼런스가 있다.

#### 람다의 특징
* 익명
* 함수
    * 람다는 메소드처럼 특정 클래스에 종속되지 않으므로 함수라고 부른다. 하지만 메소드처럼 파라미터 리스트, 바디, 리턴 타입, 발생 가능한 예외 리스트를 포함한다.
    * 객체지향에서 객체의 행위가 메소드였다. 함수라고하는 것은 객체의 행위가 아니라 람다는 수학적 계산과 같은 기능이 크기 때문에 함수라고 하는 것 같다.
* 전달
    * 메소드 인자로 람다 표현식을 전달하거나 변수로 저장할 수 있다.
* 간결성

#### 람다
```
// 1. (parameters) -> expression
// 2. (parameters) -> { return statements; }
appleList.sort((o1, o2) -> o1.getWeight() - o2.getWeight());
```
* 파라미터 : 함수형 인터페이스의 메소드 파라미터
* 화살표 : 파라미터와 람다 본문(바디)을 분리
* 바디 : 람다의 리턴 값

#### 함수 디스크립터
* 함수형 인터페이스의 추상 메소드 시그니처는 람다 표현식의 시그니처를 가리킨다. 그리고 그 시그니처를 서술하는 메소드를 함수 디스크립터라고 한다. 간단하게 함수형 인터페이스의 추상 메소드가 어떤 파라티머를 받고 어떤 타입을 리턴하는가에 대한 것이다.
    * 파라미터 + 리턴 타입 = 시그니처 ?
    * 시그니처가 같다면 그에 일치하는 람다를 전달할 수 있다.
* @FunctionalInterface
    * Java8에는 새로운 어노테이션이 추가되었다. 이 어노테이션은 함수형 인터페이스임을 명시적으로 나타낸다. 정확히 명시적으로 나타낼뿐만 아니라 실제로 추상 메소드가 두 개 이상이라면 컴파일러가 에러를 발생시킨다.
        * `Multiple nonoverriding abstract methods found in interface XXX`

#### 람다 활용 : 실행 어라운드 패턴(Execute Around Pattern)
* 람다를 통한 동작 파라미터 구현을 작업 처리의 관점에서 작게 나누어보면 다음과 같다.
    1. 자원의 설정
    2. 자원의 정리
* 설정과 정리, 이 두 과정을 둘러싼 형태를 `실행 어라운드 패턴`이라 한다.

#### (미리 정의된) 함수형 인터페이스
* 함수형 인터페이스의 추상 메소드 시그니처를 함수 디스크립터라 한다. 그리고 다양한 람다를 지원하기 위해 공통의 함수 디스크립터를 기술하는 함수형 인터페이스 집합이 있다.
* 기존의 함수형 인터페이스
    * Comparable
    * Runnable
    * Callable
* Java 8의 대표적인 함수형 인터페이스
    * Predicate
    * Consumer
    * Function
    
#### Predicate<T>
* test(T t)
    * 인자 : T
    * 리턴 : boolean
* T를 인자로 받아 어떤 로직을 수행하고 그에 대한 boolean 값을 리턴

#### Consumer<T>
* accept(T t)
    * 인자 : T
    * 리턴 : void
* T를 인자로 받아 어떤 로직을 수행하고 싶을 때

#### Function<T, R>
* apply(T t)
    * 인자 : T
    * 리턴 : R
* T를 인자로 받아 어떤 로직을 수행하고 R을 리턴

#### Supplier<T>
* get()
    * 리턴 : T
* 무인자 함수로, 새로운 객체 T를 생성하여 리턴

#### 타입 체크, 타입 추론, 제약
* 람다는 콘텍스트를 이용해서 람다의 타입 추론이 가능하다. 어떤 context에서 기대되는 람다 표현식의 형식을 대상 형식이라 한다.
* 대상 형식이 같다면, 다른 함수형 인터페이스여도 서로 호환 가능하다.
* 지역 변수 사용
    * 람다 표현식에서는 외부에 정의된 변수(자유 변수)를 활용할 수 있다. 하지만 이때 동작은 람다 캡쳐링이라 한다. 외부 변수를 활용할 수 있지만 약간의 제약이 따른다. 람다는 인스턴스 변수와 정적 변수를 자유롭게 캡처할 수 있다. 캡처란 람다의 바디 내부에서 참조할 수 있는 것을 말한다.
    * 외부 변수를 사용할 경우 명시적으로 final 변수이거나, 실질적으로 final 변수와 같이 사용되어야 한다.
        * 실질적으로 final 변수와 같이 사용되어야 한다??? 값이 한 번만 할당되어서 상수처럼 변하지 않는 데이터처럼 사용되어야 한다는 것인가?
    * 지역 변수의 제약, why?
        * 인스턴스 변수는 heap에 저장되는 반면, 지역 변수는 stack에 저장된다. 람다에서 지역 변수에 바로 접근할 수 있다는 가정하에 람다가 스레드에서 실행된다면 <U>변수를 할당한 스레드(메소드 호출시 생성된 스레드)</U>가 사라져서 변수 할당이 해제되었는데도 람다를 실행하는 스레드에는 해당 변수에 접근하는 문제가 생긴다.
        * 그래서 외부 변수에 접근할 때, 직접 접근이 아닌 복사본(캡처)을 뜨는 것이다.
        * **언뜻보면, JS 같은 언어에서 클로저로 인해 생기는 안전하지 못한 동작을 예방하기 위해 캡처 방식을 사용하는 것 같다.**

#### 메소드 레퍼런스
* 가독성 굳
* 람다에서 메소드 래퍼런스로 변경
    1. (args) -> ClassName.staticMethod(args);
        * ClassName.staticMethod
    2. (arg0, rest) -> arg0.instanceMethod(rest);
        * ClassName::instanceMethod
    3. (args) -> expr.instanceMethod(args);
        * expr::instanceMethod
* 예시
    * (String s) -> Integer.parseInt(s);
        * Integer::parseInt
    * XXX<List<String>, String> contains = (list, element) -> list.contains(element);
        * List::contains