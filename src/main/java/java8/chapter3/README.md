## CHAPTER 3. 람다 표현식
* 익명 클래스를 활용한 동작 파라미터화는 다양한 요구사항에 유연성있는 코드이지만, 아직 깔끔하지 못한 코드이다. 그래서 람다 표현식을 사용하여 더욱 깔끔한 코드를 구현할 수 있다.
* 람다 뿐만 아니라 자바 8에는 메소드 레퍼런스가 있다.

#### 람다의 특징
* 익명
* 함수
    * 람다는 메소드처럼 특정 클래스에 종속되지 않으므로 함수라고 부른다. 하지만 메소드처럼 파라미터 리스트, 바디, 리턴 타입, 발생 가능한 예외 리스트를 포함한다.
    * 객체지향에서 객체의 행위가 메소드였다. 함수라고하는 것은 객체의 행위가 아니라 람다는 수학적 계산과 같은 기능이 크기 때문에 함수라고 하는 것 같다.
* 전달
    * 메소드 인자로 람다 표현식을 전달하거나 변수로 저장할 수 있다.
* 간결성

#### 람다
```
// 1. (parameters) -> expression
// 2. (parameters) -> { return statements; }
appleList.sort((o1, o2) -> o1.getWeight() - o2.getWeight());
```
* 파라미터 : 함수형 인터페이스의 메소드 파라미터
* 화살표 : 파라미터와 람다 본문(바디)을 분리
* 바디 : 람다의 리턴 값

#### 함수 디스크립터
* 함수형 인터페이스의 추상 메소드 시그니처는 람다 표현식의 시그니처를 가리킨다. 그리고 그 시그니처를 서술하는 메소드를 함수 디스크립터라고 한다. 간단하게 함수형 인터페이스의 추상 메소드가 어떤 파라티머를 받고 어떤 타입을 리턴하는가에 대한 것이다.
    * 파라미터 + 리턴 타입 = 시그니처 ?
    * 시그니처가 같다면 그에 일치하는 람다를 전달할 수 있다.
* @FunctionalInterface
    * Java8에는 새로운 어노테이션이 추가되었다. 이 어노테이션은 함수형 인터페이스임을 명시적으로 나타낸다. 정확히 명시적으로 나타낼뿐만 아니라 실제로 추상 메소드가 두 개 이상이라면 컴파일러가 에러를 발생시킨다.
        * `Multiple nonoverriding abstract methods found in interface XXX`

#### 람다 활용 : 실행 어라운드 패턴(Execute Around Pattern)
* 람다를 통한 동작 파라미터 구현을 작업 처리의 관점에서 작게 나누어보면 다음과 같다.
    1. 자원의 설정
    2. 자원의 정리
* 설정과 정리, 이 두 과정을 둘러싼 형태를 `실행 어라운드 패턴`이라 한다.

#### (미리 정의된) 함수형 인터페이스
* 함수형 인터페이스의 추상 메소드 시그니처를 함수 디스크립터라 한다. 그리고 다양한 람다를 지원하기 위해 공통의 함수 디스크립터를 기술하는 함수형 인터페이스 집합이 있다.
* 기존의 함수형 인터페이스
    * Comparable
    * Runnable
    * Callable
* Java 8의 대표적인 함수형 인터페이스
    * Predicate
    * Consumer
    * Function
    
#### Predicate

#### Consumer

#### Function